\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[italian]{varioref}
\usepackage{datetime}
\selectlanguage{italian}
\usepackage[Algoritmo]{algorithm}
\usepackage{algpseudocode}

\hfuzz=100.0pt  % ignore paragraph lengths warnings

\usepackage[square,sort,comma,numbers]{natbib}

\newdate{date}{06}{09}{2021}
\title{\textsc{LittleMan}\\
%\large Relazione del progetto per l'insegnamento di Algoritmi e Strutture di Dati}
\large Relazione del progetto per il corso di Algoritmi e Strutture di Dati}
\author{
  Mattia Girolimetto (0000977478),
  Luca Tagliavini (0000971133)
}
\date{
	Universit\`a di Bologna \\
  \displaydate{date}
}

\begin{document}

\maketitle

\section*{Problema computazionale}

Lo scopo del progetto \`e quello di implementare un algoritmo efficiente e ottimale
volto alla ricerca delle mosse migliori in un gioco $(m,n,k)$, dove si devono
allineare $k$ simboli in una griglia $m \times n$.

Assumendo non esistano stati invalidi il nodo iniziale (la griglia vuota)
ha $m \times n$ figli, i quali avranno a loro volta $(m \times n)-1$ figli e cos\`i
via fino a profondit\`a $mn$ dove si avranno tutte le foglie. Il numero totale
dei nodi \`e dunque superiormente limitato da $O((m \times n) \cdot ((m \times n)-1)
\cdot \ldots \cdot 1) = O((m \times n)!)$.
Il fattore di diramazione \`e dunque elevato ad ogni stato della partita, il che
impone a un qualunque algoritmo di ricerca per forza bruta la limitazione in
profondit\`a su griglie non banali. L'impossibilit\`a di raggiungere le foglie
richiede una valutazione euristica per poter assegnare un valore a nodi intermedi
senza esplorarli.

\section*{Soluzione adottata}

<<<<<<< HEAD
Il giocatore implementato fa uso di una variante dell'algoritmo \textsc{MiniMax} con potatura
\textsc{AlphaBeta} denominata \textsc{PrincipalVariationSearch}~\cite{negascout}. Questa
consiste in una ricerca limitata in profondit\`a analoga ad \textsc{AlphaBeta}, espandendo 
interamente i nodi pi\`u promettenti e parzialmente quelli restanti. Applicando
una \textsc{IterativeDeepeningSearch}~\cite{id} si possono ordinare i sottoalberi
basandosi sui valori euristici delle ricerche precedenti e si pu\`o raggiungere
la profondit\`a massima nei limiti imposti.

Si nota facilmente che diverse combinazioni di mosse possono portare alla stessa 
situazione di gioco.
Per evitare di analizzarli pi\`u volte, gli stati di gioco vengono quindi mantenuti 
dentro una \emph{tabella delle trasposizioni}. Il valore di quelli non finali
viene stimato da una componente euristica che tiene in considerazione il numero
di serie di ogni giocatore e la relativa lunghezza, favorendo quelle di lunghezza
$k-1$, $k-2$ e $k-3$.

\subsection*{Iterative Deepening}

La ricerca della mossa migliore viene gestita da un algoritmo di
\textsc{IterativeDeepeningSearch}~\cite{id}, il quale procede applicando \textsc{MiniMax} 
con profondit\`a sempre maggiore e restituisce l'ultimo risultato trovato prima dello
scadere del tempo. Questo non peggiora la complessit\`a asintotica in quanto il
solo costo della ricerca alla massima profondit\`a assorbe quello di tutte
le chiamate precedenti. Si ha tuttavia un aumento delle operazioni totali svolte
dal calcolatore, mitigato per\`o dall'utilizzo della \textsc{PrincipalVariationSearch} 
e dalle potature derivate dall'ordinamento dei nodi ottenuto grazie a questa tecnica.

\subsection*{Tabella delle trasposizioni}

La cache fa uso della struttura dati HashMap fornita da Java generando le chiavi 
in modo incrementale tramite la tecnica di \emph{Zobrist}~\cite{zobrist}. 
Ad ognuna di esse sono associate le seguenti informazioni:
\begin{enumerate}
  \item Numero di celle marcate e ultimo simbolo giocato
  \item Profondit\`a della ricerca
  \item Tipo e valore della griglia
\end{enumerate}
Poich\`e una tavola di gioco $(m,n)$ pu\`o al pi\`u assumere $3^{mn}$ stati differenti e
un \verb!long! pu\`o contenere al pi\`u $2^{64} \approx 1.8 \cdot 10^{19}$ valori distinti,
esistono configurazioni che creano collisioni: ad esempio un gioco $(8, 8, 4)$
pu\`o avere fino a $3^{64} \approx 2.3 \cdot 10^{30}$ stati. Per limitare questo
fenomeno si verifica che il numero di mosse e l'ultimo simbolo giocato
corrispondano con i valori della griglia attuale.

Per evitare ulteriori collisioni interne alla HashMap, alla fine di ogni turno,
vengono rimosse dalla tabella delle trasposizioni tutte le tabelle di gioco
\emph{inaccessibili}. Una griglia viene definita inaccessibile quando ha un numero di
celle marcate inferiore a quello del tavolo di gioco attuale incrementato di $1$.

\subsection*{Principal Variation Search}

L'algoritmo visita in modo ordinato i figli di ogni stato di gioco applicando
limiti $\alpha$-$\beta$ differenti ad ognuno di essi al fine di aumentare il numero di potature.
Si analizza in modo approfondito il nodo pi\`u promettente, denominato \emph{Principal
Variation}, per poi visitare i restanti nodi con una ricerca a finestra \emph{nulla}~\cite{scout}
(dove i due limiti differiscono di $1$). Se questa restituisce un valore compreso
nell'intervallo $\alpha$-$\beta$ originale potrebbe essere d'interesse e dunque viene
svolta una ricerca classica.
% TODO IN REALTA' E' EURISTICA QUESTA E FAREBBE BENE METTERLA SOTTO

Nel caso in cui esista una serie $k-1$ per un qualunque giocatore si provvede a
riempire la cella mancante, evitando la ricerca di forza bruta. Viene data la
precedenza alle serie appartenenti al giocatore che deve svolgere la mossa.

\subsection*{Valutazione euristica}

La griglia di gioco mantiene al suo interno una valutazione euristica 
aggiornata progressivamente con l'avanzare della partita (Algoritmo \vref{alg:eval}).
Quando una cella viene marcata si valuta la variazione del valore euristico osservando
le righe, colonne e diagonali passanti per essa. Vengono privilegiate le serie consecutive 
di $k-1, k-2$ o $k-3$ elementi, dando un peso inferiore a segmenti pi\`u corti.
La quotazione di un tavolo di gioco \`e il risultato della differenza tra i
valori delle serie dei due giocatori. Inoltre, per favorire le griglie che
assumono valori promettenti con il minor numero di mosse, ogni
valutazione viene divisa per il numero di simboli sulla griglia.

Questo approccio ricorda quello scelto da \citeauthor{chuan} per il gioco di Go~\cite{chuan},
tuttavia si \`e preferito favorire anche serie di lunghezza inferiore per migliorare 
l'accuratezza della \emph{Principal Variation}, in particolare durante le mosse iniziali.

\begin{algorithm}[H]
  \caption{Valutazione eurstica procedurale}
  \label{alg:eval}
  \begin{algorithmic}[0]
    \Procedure {Eval}{$i$, $j$}
      \State $value \gets 0$
      \For{$(ii, jj) \in \Call{Row}{i}$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 0, 1}$
      \EndFor
      \For{$(ii, jj) \in \Call{Column}{j}$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 1, 0}$
      \EndFor
      \For{$(ii, jj) \in \Call{Diagonal}{i, j}$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 1, 1}$
      \EndFor
      \For{$(ii, jj) \in \Call{AntiDiagonal}{i, j}$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 1, -1}$
      \EndFor
      \State \Return $value$
    \EndProcedure
    \Statex
    \Procedure {CellValue}{$i$, $j$, $\delta_i$, $\delta_j$}
      \If{$n_{free} + n_1 + n_2 \geq k$} \Comment{Se la serie \`e troppo lunga}
        \State $s \gets B[i - \delta_i \cdot k][j - \delta_j \cdot k]$ \Comment{Stato della prima cella nella serie}
        \State decrement $n_{free}, n_1, n_2$ by $1$ based on $s$
      \EndIf
      \State increment $n_{free}, n_1, n_2$ by $1$ based on $B[i][j]$
      \Statex
      \If{$n_1 + p_{free} = k$}
        \Comment{Si restituisce la valutazione della serie}
        \State \Return $color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_1^2)$
      \ElsIf{$n_2 + p_{free} = k$}
        \State \Return $-color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_2^2)$
      \Else
        \State \Return $0$
      \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection*{Altre euristiche considerate}

In questa sezione sono presentati approcci che sono stati considerati e
implementati, ma in definitiva scartati in quanto non hanno offerto un
miglioramento apprezzabile allo stile di gioco dell'algoritmo.

\subsubsection*{Valutazione euristica degli spazi vuoti}

Nel gioco generalizzato del $(m, n, k)$, specialmente per valori di $k < \max\{m,n\}$,
una sequenza con celle libere ai lati pu\`o rivelarsi pi\`u vantaggiosa di una
limitata. Ad esempio quando una sequenza \`e del tipo $k-1$ ed ha entrambi i lati liberi
garantisce la vittoria al giocatore. Si pu\`o dunque estendere l'Algoritmo
\vref{alg:eval} affinch\`e sommi un bonus a serie di questo tipo.
Ecco una possibile implementazione che si pu\`o trovare
commentata anche nel codice sorgente:

\begin{algorithm}[H]
  \caption{Valutazione delle serie favorendo spazi liberi adiacenti}
  \label{alg:eval_free}
  \begin{algorithmic}[0]
    \Procedure {CellValue}{$i$, $j$, $\delta_i$, $\delta_j$}
    \Comment{La logica rimane invariata fino alla valutazione della serie attuale}
    \State $bonus \gets 0$
    \If{$B[i + \delta_i][j + \delta_j] = free$}
      \State $bonus \gets bonus + \textsc{BonusConstant}$
    \EndIf
    \If{$B[i - \delta_i \cdot (k+1)][j - \delta_j \cdot (k+1)] = free$}
      \State $bonus \gets bonus + \textsc{BonusConstant}$
    \EndIf
    \Statex
    \If{$n_1 + p_{free} = k$}
      \State \Return $color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_1^2 + bonus)$
    \ElsIf{$n_2 + p_{free} = k$}
    \State \Return $-color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_2^2 + bonus)$
    \Else
      \State \Return $0$
    \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Va ricordato che nell'Algoritmo~\ref{alg:eval_free} il controllo della validit\`a delle
posizioni $(i + \delta_i, j + \delta_j)$ e $(i - \delta_i \cdot (k+1), j - \delta_j \cdot (k+1))$
\`e stato omesso per brevit\`a e chiarezza del codice.

\subsubsection*{Ricerca quiescente}

Un problema ben noto negli algoritmi di ricerca a profondit\`a limitata \`e
quello dell'\emph{effetto orizzonte}, causato dall'impossibilt\`a 
di visitare l'albero di gioco oltre un certo livello. Ci\`o porta spesso a scegliere 
mosse che si rivelano catastrofiche in pochi turni di gioco. 
Una soluzione al problema chiamata \emph{ricerca quiescente} \cite{quiescence} fu per la prima
volta proposta  da \citeauthor{quiescence} nel \citeyear{quiescence}.

L'idea \`e quella di esplorare ulteriormente gli stati che appaiono "calmi", o
appunto "quiescenti", poich\`e sono quelli pi\`u proni a degenerare in sconfitte.
Uno stato di gioco viene ritenuto calmo quando il suo valore euristico \`e inferiore
ad una data soglia. Si pu\`o dunque modificare la funzione di valutazione affinch\`e
applichi una \textsc{QuiescensceSearch} ove necessario, come mostrato di seguito:

\begin{algorithm}[H]
  \caption{Ricerca quiescente con struttura \textsc{NegaMax}}
  \label{qs}
  \begin{algorithmic}[0]
    \Procedure{Evalaute}{$board$, $raw$}
      \State $eval \gets $ valutazione euristica
      \If{$raw$ \textbf{or} $|eval| > \textsc{QuiescenceThreshold}$}
        \State \Return $eval$
      \Else
        \State $color \gets 1$
        \If{next moving player of the $board$ is $enemy$}
          \State $color \gets -1$
        \EndIf
        \State \Return \Call{QuiescenceSearch}{$board$, $color$, \textsc{QuiescenceDepth}}
      \EndIf
    \EndProcedure
    \Statex
    \Procedure{QuiescenceSearch}{$node$, $color$, $depth$}
    \If{$depth = 0$ \textbf{or} node is leaf}
      \State \Return \Call{Evaluate}{$node$, $true$}
    \EndIf
    \State $best \gets -\infty$
    \For{$child$ of $node$}
      \State $best \gets \max\{best, \Call{QuiescenceSearch}{child, -color, depth-1}\}$
    \EndFor
    \State \Return $-best$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

La funzione \textsc{Evaluate} viene chiamata dall'algoritmo di ricerca con il valore
dell'argomento $raw$ uguale a $false$.

Nella pratica questa modifica non ha portato a significativi miglioramenti
ma ha caratterizzato l'AI con uno stile di eccesivamente difensivo, il quale ne
ha peggiorato le prestazioni contro giocatori poco astuti o casuali.
Si pu\`o imputare questo fallimento a due fattori:
\begin{enumerate}
  \item La scarsa precisione della valutazione euristica.
  \item Nei giochi $(m, n, k)$ una qualunque mossa di un giocatore migliora sempre
    e soltanto il proprio punteggio: in questo modo i valori delle valutazioni
    oscillano e non convergono mai ad una stima appropriata, in particolar modo
    nelle fasi iniziali della partita.
\end{enumerate}

\subsection*{Miglioramenti futuri}

Sono noti in letteratura una serie di algoritmi e valutazioni euristiche utili
nel gioco $(m, n, k)$ che potrebbero migliorare le prestazioni dell'attuale
giocatore. Ecco un elenco dei pi\`u significativi:
\begin{enumerate}
  \item Adottare un'euristica per la valutazione pi\`u raffinata. Questo cambiamento
    avrebbe il maggiore impatto: un conteggio delle minacce~\cite{heur}
    analoga a quella proposta da \citeauthor{heur} migliorerebbe significativamente
    la precisione sugli stati pi\`u avanzati del gioco. \label{newheur}
  \item La \textsc{QuiescenceSearch} potrebbe portare ulteriori vantaggi se
    abbinata a una strategia analoga a quella descritta nel punto \vref{newheur}.
  \item \`E stato infine mostrato come altre variazioni di \textsc{AlphaBeta} e
    \textsc{IterativeDeepeningSearch} come MTD(f)~\cite{mtdf} possono portare a
    risultati ancora migliori nel gioco degli scacchi. Riteniamo sia prima
    necessario compiere il passo \vref{newheur} affinch\`e si riveli efficace anche nel nostro ambito.
\end{enumerate}

% \pagebreak
\bibliography{report}
\bibliographystyle{IEEEtranN}

\end{document}
