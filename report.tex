\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[italian]{varioref}
\usepackage{datetime}
\selectlanguage{italian}
\usepackage[Algoritmo]{algorithm}
\usepackage{algpseudocode}

\hfuzz=100.0pt  % ignore paragraph lengths warnings

\usepackage[square,sort,comma,numbers]{natbib}

\newdate{date}{06}{09}{2021}
\title{Little Man\\
\large Relazione del progetto per l'insegnamento di Algoritmi e Strutture di Dati}
\author{
  Mattia Girolimetto (0000977478),
  Luca Tagliavini (0000971133)
}
\date{
	Universit\`a di Bologna \\
  \displaydate{date}
}

\begin{document}

\maketitle

\section*{Problema computazionale}

Lo scopo del progetto \`e quello di implementare un algoritmo efficiente e ottimale
volto alla ricerca delle mosse migliori in un gioco $(m,n,k)$, dove si devono
allineare $k$ simboli in una griglia $m \times n$.

Si fa uso di una variante dell'algoritmo \textsc{MiniMax} con potatura
\textsc{AlphaBeta} denominata \textsc{PrincipalVariationSearch}~\cite{negascout}. Questa
prevede  una ricerca limitata in profondit\`a analoga a \textsc{AlphaBeta}, espandendo 
interamente i nodi pi\`u promettenti e parzialmente quelli restanti. Applicando
una \textsc{IterativeDeepeningSearch}~\cite{id} si possono ordinare i sottoalberi
basandosi sui valori euristici delle ricerche precedenti e si pu\`o raggiungere
la profondit\`a massima nei limiti imposti.

Diverse combinazioni di mosse possono portare a stati gi\`a analizzati
precedentemente, i quali vengono mantenuti dentro una tabella delle trasposizioni
per evitare di valutarli pi\`u volte. Il valore degli stati di gioco non finali
viene stimato da una componente euristica che tiene in considerazione il numero
di serie di ogni giocatore, la relativa lunghezza e favorisce quelle di lunghezza
$k-1$, $k-2$, $k-3$.

\subsection*{Iterative Deepening}

La ricerca della mossa migliore viene gestita da un algoritmo di
\textsc{IterativeDeepeningSearch}~\cite{id}, il quale procede applicando MiniMax
con profondit\`a sempre maggiore e restituisce il risultato pi\`u recente allo
scadere del tempo. Questo non peggiora la complessit\`a asintotica in quanto il
solo costo della ricerca alla massima profondit\`a assorbe quello di tutte
le chiamate precedenti. Si ha tuttavia un aumento delle operazioni totali svolte
dal calcolatore, che vinene mitigato dall'utilizzo della
\textsc{PrincipalVariationSearch} e dalle potature che seguono combinando queste
due tecniche.

\subsection*{Tabella delle trasposizioni}

La cache fa uso della struttura dati HashMap fornita da Java generando le chiavi 
in modo incrementale tramite la tecnica di \emph{Zobrist}~\cite{zobrist}. A ogni
chiave sono associate le seguenti informazioni:
\begin{enumerate}
  \item Numero di celle marcate e ultimo simbolo giocato
  \item Profondit\`a della ricerca
  \item Tipo e valore della griglia
\end{enumerate}
Poich\`e una board $(m,n)$ pu\`o al pi\`u assumere $3^{mn}$ stati differenti e
un \verb!long! pu\`o contenere al pi\`u $2^{64} \approx 1.8 \cdot 10^{19}$ valori distinti,
esistono configurazioni che creano collisioni: ad esempio un gioco $(8, 8, 4)$
pu\`o avere fino a $3^{64} \approx 2.3 \cdot 10^{30}$ stati. Per limitare questo
fenomeno si verifica che il numero di mosse e l'ultimo simbolo giocato combacino.

Per evitare ulteriori collisioni interne alla HashMap di Java, alla fine di
ogni turno, la tabella delle trasposizioni viene privata delle griglie \emph{
inaccessibili}. Una griglia viene definita inacessibile quando ha un numero di
celle marcate inferiore a quello del tavolo di gioco attuale incrementato di $1$.

\subsection*{Principal Variation Search}

L'algoritmo visita in modo ordinato i figli di ogni stato di gioco, applicando
limiti $\alpha$-$\beta$ differenti ad ognuno di essi ai fini di aumentare le potature.
Si analizza in modo approfondito il nodo pi\`u promettente, denominato \emph{Principal
Variation}, per poi visitare i restanti nodi con una ricerca a finestra \emph{nulla}~\cite{scout}
(dove i limiti differiscono di $1$). Se essa restituisce un valore compreso
negli $\alpha$-$\beta$ originali potrebbe essere d'interesse e dunque viene
svolta una ricerca classica.
% TODO IN REALTA' E' EURISTICA QUESTA E FAREBBE BENE METTERLA SOTTO

Nel caso in cui esista una serie $k-1$ per un qualunque giocatore si provvede a
riempire la cella mancante, evitando la ricerca di forza bruta. Viene data la
precedenza alle serie appartenenti al giocatore che deve svolgere la mossa.

\subsection*{Valutazione euristica}

La griglia di gioco mantiene al suo interno una valutazione euristica che viene
aggiornata progressivamente con l'avanzare della partita (Algoritmo \vref{alg:eval}).
Quando una cella viene marcata si valuta la variazione del valore euristico osservando
le righe, colonne e diaginali che passano per essa. Vengono favorite le serie initerrotte
di $k-1, k-2$ o $k-3$ elementi, dando un peso inferiore a segmenti pi\`u corti.
La quotazione di un tavolo di gioco \`e il risultato della differenza tra i
valori delle serie dei due giocatori. Oltretutto vengono favorite griglie che
assumono valori promettenti con il minor numero di mosse, dividendo ogni
valutazione per la profondit\`a dello stato di gioco.

Questo approccio ricorda quello scelto da Chuan per il gioco di Go~\cite{chuan},
tuttavia si \`e preferito favorire anche serie di lunghezza inferiore ai fini di
stimare una pi\`u accurata \emph{Principal Variation}, sopratutto durante le
mosse iniziali.

\begin{algorithm}
  \caption{Valutazione eurstica procedurale}
  \label{alg:eval}
  \begin{algorithmic}[0]
    \Procedure {Eval}{$i$, $j$}
      \State $value \gets 0$
      \For{$(ii, jj) \in$ row $i$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 0, 1}$
      \EndFor
      \For{$(ii, jj) \in$ column $i$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 1, 0}$
      \EndFor
      \For{$(ii, jj) \in$ diagonal at $(i, j)$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 1, 1}$
      \EndFor
      \For{$(ii, jj) \in$ anti-diagonal at $(i, j)$}
        \State $value \gets value + \Call{CellValue}{ii, jj, 1, -1}$
      \EndFor
      \State \Return $value$
    \EndProcedure
    \Statex
    \Procedure {CellValue}{$i$, $j$, $\delta_i$, $\delta_j$}
      \If{$n_{free} + n_1 + n_2 \geq k$} \Comment{Se la serie \`e troppo lunga}
        \State $s \gets B[i - \delta_i \cdot k][j - \delta_j \cdot k]$ \Comment{Stato della prima cella nella serie}
        \If{$s = free$}
          \State $n_{free} \gets n_{free} - 1$
        \ElsIf{$s = player_1$}
          \State $n_1 \gets n_1 - 1$
        \Else
          \State $n_2 \gets n_2 - 1$
        \EndIf
      \EndIf
      \If{$B[i][j] = free$}
        \State $n_{free} \gets n_{free} + 1$
      \ElsIf{$B[i][j] = player_1$}
        \State $n_1 \gets n_1 + 1$
      \Else \Comment{La cella appartiene al giocatore $2$}
        \State $n_2 \gets n_2 - 1$
      \EndIf
      \Statex
      \If{$n_1 + p_{free} = k$}
        \Comment{Si restituisce la valutazione della serie}
        \State \Return $color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_1^2)$
      \ElsIf{$n_2 + p_{free} = k$}
        \State \Return $-color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_2^2)$
      \Else
        \State \Return $0$
      \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection*{Altre euristiche considerate}

In questa sezione saranno presentati approcci che sono stati considerati
e/o implementati, ma in definitiva scartati in quanto non hanno offerto un
miglioramento apprezzabile allo stile di gioco dell'algoritmo.

\subsubsection*{Valutazione euristica degli spazi vuoti}

Nel gioco generalizzato del $(m, n, k)$, specialmente per valori di $k < \max\{m,n\}$,
una sequenza con celle libere ai lati pu\`o rivelarsi pi\`u vantaggiosa di una
limitata: quando la sequenza \`e del tipo $k-1$ ed ha entrambi i lati liberi
essa garantisce la vittoria al giocatore. Si pu\`o dunque estendere l'Algoritmo
\vref{alg:eval} affinch\`e sommi un bonus se la serie sotto analisi contiene celle
libere attorno a se. Ecco una possibile implementazione che si pu\`o trovare
commentata anche nel codice sorgente:

\begin{algorithm}
  \caption{Valutazione delle serie favorendo spazi liberi adiacenti}
  \label{alg:eval_free}
  \begin{algorithmic}[0]
    \Procedure {CellValue}{$i$, $j$, $\delta_i$, $\delta_j$}
    \Comment{La logica rimane invariata fino alla valutazione della serie attuale}
    \State $bonus \gets 0$
    \If{$B[i + \delta_i][j + \delta_j] = free$}
      \State $bonus \gets bonus + \textsc{BonusConstant}$
    \EndIf
    \If{$B[i - \delta_i \cdot (k+1)][j - \delta_j \cdot (k+1)] = free$}
      \State $bonus \gets bonus + \textsc{BonusConstant}$
    \EndIf
    \Statex
    \If{$n_1 + p_{free} = k$}
      \State \Return $color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_1^2 + bonus)$
    \ElsIf{$n_2 + p_{free} = k$}
    \State \Return $-color \cdot (\Call{LargeSeriesConstant}{n_{free}} + n_2^2 + bonus)$
    \Else
      \State \Return $0$
    \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Va ricordato che nell'Algoritmo~\ref{alg:eval_free} il controllo della validit\`a delle
posizioni $(i + \delta_i, j + \delta_j)$ e $(i - \delta_i \cdot (k+1), j - \delta_j \cdot (k+1))$
\`e stato omesso per brevit\`a e chiarezza del codice.

\subsubsection*{Ricerca quiescente}

Un problema ben noto negli algoritmi di ricerca a profondit\`a limitata \`e
quello dell'\emph{effetto orizzonte}, causato dall'impossibilt\`a della procedura
di visitare l'albero oltre un certo margine. Ci\`o porta spesso alla scelta di
mosse che si rivelano catastrofiche in pochi turni di gioco. Una soluzione al
problema chiamata \emph{ricerca quiescente} \cite{quiescence} fu per la prima
volta proposta  da \citeauthor{quiescence} nel \citeyear{quiescence}.

L'idea \`e quella di esplorare ulteriormente gli stati che appaiono "calmi", o
appunto "quiescenti", poich\`e sono quelli pi\`u proni a degenerare in sconfitte.
Si pu\`o dunque modificare la funzione di valutazione in modo da applicare una
\textsc{QuiescensceSearch} come mostrato di seguito:

\begin{algorithm}
  \caption{Ricerca quiescente con struttura \textsc{NegaMax}}
  \label{qs}
  \begin{algorithmic}[0]
    \Procedure{Evalaute}{$board$, $raw$}
      \State $eval \gets $ valutazione euristica
      \If{$raw$ \textbf{or} $|eval| > \textsc{QuiescenceThreshold}$}
        \State \Return $eval$
      \Else
        \State $color \gets 1$
        \If{next moving player of the $board$ is $enemy$}
          \State $color \gets -1$
        \EndIf
        \State \Return \Call{QuiescenceSearch}{$board$, $color$, \textsc{QuiescenceDepth}}
      \EndIf
    \EndProcedure
    \Statex
    \Procedure{QuiescenceSearch}{$node$, $color$, $depth$}
    \If{$depth = 0$ \textbf{or} node is leaf}
      \State \Return \Call{Evaluate}{$node$, $true$}
    \EndIf
    \State $best \gets -\infty$
    \For{$child$ of $node$}
      \State $best \gets \max\{best, \Call{QuiescenceSearch}{child, -color, depth-1}\}$
    \EndFor
    \State \Return $-best$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

In questo modo un ristretto gruppo di nodi selezionati (coloro che hanno valore
euristico inferiore a \textsc{QuiescenceThreshold}) vengono visitati a maggiore
profondit\`a nella speranza di stabilizzare la loro valutazione.

Nella pratica questa modifica non ha portato a significativi miglioramenti,
ma ha caratterizzato l'AI con uno stile di gioco pi\`u difensivo, che ne ha
peggiorato le prestazioni contro giocatori poco astuti o casuali.
Si pu\`o imputare questo fallimento a due fattori:
\begin{enumerate}
  \item La scarsa precisione della valutazione euristica.
  \item Le propriet\`a dei giochi $(m,n,k)$ per cui qualunque mossa di un
    giocatore migliora il proprio punteggio: in questo modo i valori delle
    valutazioni oscillano e non convergono mai ad una stima appropriata, in
    particolar modo a basse profondit\`a.
\end{enumerate}

% TODO: parlare di pattern move, non fatto ma simile a favorire le k... .

\pagebreak
\bibliography{report}
\bibliographystyle{IEEEtranN}

\end{document}
